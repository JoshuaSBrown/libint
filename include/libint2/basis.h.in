/*
 *  This file is a part of Libint.
 *  Copyright (C) 2004-2014 Edward F. Valeev
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Library General Public License, version 2,
 *  as published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public License
 *  along with this program.  If not, see http://www.gnu.org/licenses/.
 *
 */

#ifndef _libint2_src_lib_libint_basis_h_
#define _libint2_src_lib_libint_basis_h_

#include <libint2/cxxstd.h>
#if LIBINT2_CPLUSPLUS_STD < 2011
# error "libint2/basis.h requires C++11 support"
#endif

#include <iostream>
#include <fstream>
#include <vector>
#include <stdexcept>
#include <map>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <libint2.h>
#include <libint2/shell.h>
#include <libint2/atom.h>
#include <libint2/chemistry/elements.h>

#include <boost/lexical_cast.hpp>

namespace libint2 {

  /// BasisSet is a slightly decorated \c std::vector of \c libint2::Shell objects.
  class BasisSet : public std::vector<libint2::Shell> {
    public:
      BasisSet() : name_(""), nbf_(-1), max_nprim_(0), max_l_(-1) {}
      BasisSet(const BasisSet&) = default;
      BasisSet(BasisSet&& other) :
        std::vector<libint2::Shell>(std::move(other)),
        name_(std::move(other.name_)),
        nbf_(other.nbf_),
        max_nprim_(other.max_nprim_),
        max_l_(other.max_l_),
        shell2bf_(std::move(other.shell2bf_))
      {
      }
      ~BasisSet() = default;
      BasisSet& operator=(const BasisSet&) = default;

      /// Construct from basis set name and vector of atoms

      /**
       * @param name basis set name
       * @param atoms \c std::vector of Atom objects
       * @param name of custom basis set file and path
       * \note All atoms receive the same basis set
       * \note \c name will be "canonicalized" using BasisSet::canonicalize(name) to
       *       produce the file name where the basis will be sought. This file needs to contain
       *       the basis set definition in Gaussian94 format (see \c lib/basis directory for examples).
       *       The file will be searched in the following directories (in decreasing order of preference)
       *       <ol>
       *         <li> specified by LIBINT_DATA_PATH environmental variable, if defined </li>
       *         <li> specified by DATADIR macro variable, if defined </li>
       *         <li> specified by SRCDATADIR macro variable, if defined </li>
       *         <li> hardwired to directory \c @DATADIR_ABSOLUTE@/basis </li>
       *       </ol>
       */
      BasisSet(std::string name,
               const std::vector<Atom>& atoms, std::string customname="") : name_(std::move(name)),customname_(std::move(customname)) {

        std::map<int, std::map< std::string, std::string > > cust_basis = read_custom(customname_);
        
        // String is the basis component set
        std::map<std::string,std::vector<std::vector<std::vector<libint2::Shell>>>> all_comp_basis_sets;
        // String is the basis component set contains the names
        std::map<std::string,std::vector<std::string>> all_basis_comp_names;

        std::string basis_lib_path = data_path();
        // Reading in default basis set used for most of the atoms
        {
          // read in the library file contents
          auto canonical_name = canonicalize_name(name_);
          // some basis sets use cartesian d shells by convention, the convention is taken from Gaussian09
          auto force_cartesian_d = gaussian_cartesian_d_convention(canonical_name);

          // parse the name into components
          std::vector<std::string> basis_component_names = decompose_name_into_components(canonical_name);
          
          // ref_shells[component_idx][Z] => vector of Shells
          std::vector<std::vector<std::vector<libint2::Shell>>> component_basis_sets;
          component_basis_sets.reserve(basis_component_names.size());

          // read in ALL basis set components
          for(const auto& basis_component_name: basis_component_names) {
            auto file_dot_g94 = basis_lib_path + "/" + basis_component_name + ".g94";
            
            // use same cartesian_d convention for all components!
            component_basis_sets.emplace_back(read_g94_basis_library(file_dot_g94, force_cartesian_d));
          }
          // Fully resolved initial name
          all_comp_basis_sets[canonical_name]=component_basis_sets;
          all_basis_comp_names[canonical_name]=basis_component_names;
        }  

        
        // Reading in custom basis sets used for atoms in the custom file
        {
          for(auto item : cust_basis){
            auto basis_name = item.second.begin()->second;
            auto canonical_name = canonicalize_name(basis_name);
            auto force_cartesian_d = gaussian_cartesian_d_convention(canonical_name);
            std::vector<std::string> basis_component_names = decompose_name_into_components(canonical_name);
            std::vector<std::vector<std::vector<libint2::Shell>>> component_basis_sets;
            component_basis_sets.reserve(basis_component_names.size());
            for(const auto& basis_component_name: basis_component_names) {
              auto file_dot_g94 = basis_lib_path + "/" + basis_component_name + ".g94";
              component_basis_sets.emplace_back(read_g94_basis_library(file_dot_g94, force_cartesian_d));
            }
            all_comp_basis_sets[canonical_name]=component_basis_sets;
            all_basis_comp_names[canonical_name]=basis_component_names;
          }
        }

        std::cerr << "Finding Corresponding Basis function components" << std::endl;
        
        // for each atom find the corresponding basis components
        for(auto a=0; a<atoms.size(); ++a) {

          nbf_per_atom_[a]=0;
          // This is where we need to look to see if the specific atom has a customized basis set
          // Cust basis uses the label of the atoms which start at 1 not 0
          if(cust_basis.count(a+1)){

            std::cout << "a " << a << " has a customized basis set " << std::endl;
            // Will be using the Z for the atom we are stealing the coefficients from
            using libint2::chemistry::element_info;
            int Z = -1;
            for(const auto& e: element_info){
              std::string Sym = cust_basis[a+1].begin()->first;
              if(strcaseequal(e.symbol,Sym)){
                Z = e.Z;
                break;
              }
            }
            std::cout << "Mass Z " << Z << std::endl;
            if(Z==-1){
              std::cerr << "Element Symbol " << cust_basis[a+1].begin()->first << std::endl;
              throw std::runtime_error("Did not recognize element symbol in custom file");
            }

            auto basis_name = cust_basis[a+1].begin()->second;
            auto canonical_name = canonicalize_name(basis_name);
            auto component_basis_sets = all_comp_basis_sets[canonical_name];
            auto basis_component_names = all_basis_comp_names[canonical_name];

            // add each component in order
            for(auto comp_idx=0; comp_idx!=component_basis_sets.size(); ++comp_idx) {
              const auto& component_basis_set = component_basis_sets[comp_idx];
              
              if (component_basis_set[Z].empty())
                throw std::string("did not find the basis for this Z in ") +
                  basis_lib_path + "/" + basis_component_names[comp_idx] + ".g94";

              for(auto s: component_basis_set[Z]) {

                nbf_per_atom_[a]=nbf_per_atom_[a]+s.size();
                std::cout << "nbf_per_atom_ " << nbf_per_atom_[a] << " s.size " << s.size() << std::endl;
                this->push_back(std::move(s));
                this->back().move({{atoms[a].x, atoms[a].y, atoms[a].z}});
              } // shell loop
            } // basis component loop

          }else{

            std::cout << "Atom index " << a << " is not using a customized basis set" << std::endl;
            auto Z = atoms[a].atomic_number;
            std::cout << "Mass Z " << Z << std::endl;
            auto canonical_name = canonicalize_name(name_);
            std::cerr << "canonical name " << canonical_name << std::endl;
            auto component_basis_sets = all_comp_basis_sets[canonical_name];
            auto basis_component_names = all_basis_comp_names[canonical_name];
            // add each component in order
            for(auto comp_idx=0; comp_idx!=component_basis_sets.size(); ++comp_idx) {
              const auto& component_basis_set = component_basis_sets[comp_idx];

              if (component_basis_set[Z].empty())
                throw std::string("did not find the basis for this Z in ") +
                  basis_lib_path + "/" + basis_component_names[comp_idx] + ".g94";

              std::cout << "component_basis_set size for Z " << Z << " is " << component_basis_set.size() << std::endl;
              std::cout << "component_basis_set[Z].size() " << component_basis_set[Z].size() << std::endl; 
              for(auto s: component_basis_set[Z]) {

                std::cout << "Shell size s " << s.size() << std::endl;                
                nbf_per_atom_[a]=nbf_per_atom_[a]+s.size();
                this->push_back(std::move(s));
                this->back().move({{atoms[a].x, atoms[a].y, atoms[a].z}});

              } // shell loop
            } // basis component loop

          }
        } // atom loop

        std::cerr << "Calling init" << std::endl;
        init();
      }

        /// forces solid harmonics/Cartesian Gaussians
        /// @param solid if true, force all shells with L>1 to be solid harmonics, otherwise force all shells to Cartesian
        void set_pure(bool solid) {
          for(auto& s: *this) {
            s.contr[0].pure = solid;
          }
          init();
        }

        /// @return the number of basis functions in the basis; -1 if uninitialized
        long nbf() const {
          return nbf_;
        }

/*        std::map<int,int> nbf_per_atom(const std::vector<libint2::Shell>& shells) {
          // Shells appear in the same order as the atoms
          int atom_ind = 0;
          std::map< int, int > nbf_p_atom;
          for (const auto& shell: shells){
            nbf_p_atom[atom_ind]=shell.size();
            ++atom_ind;
          }
          return nbf_p_atom;
        }*/

        // Determine if the orbitals will be constrained or not
        bool constrain(void){
          return groups_.size()>0;
        }

        size_t numGroups(void){
          return groups_.size();
        }        

        size_t numAtoms(void){
          return nbf_per_atom_.size();
        }

        int atomGroup(int atomIndx){
          return group_[atomIndx];
        }

        int numAtomBFNs(int atomIndx){
          return nbf_per_atom_[atomIndx];
        }

        std::map<int,int> init_group(){
          std::map<int,int> group;
          size_t num_atoms = nbf_per_atom_.size();
          for( size_t i=0; i<num_atoms; ++i){
            group[i]=0;
          } 
          return group;
        }
        /// @return the maximum number of primitives in a contracted Shell, i.e. maximum contraction length; 0 if uninitialized
        size_t max_nprim() const {
          return max_nprim_;
        }
        /// @return the maximum angular momentum of a contraction; -1 if uninitialized
        size_t max_l() const {
          return max_l_;
        }
        /// @return the map from shell index to index of the first basis function from this shell
        /// \note basis functions are ordered as shells, i.e. shell2bf[i] >= shell2bf[j] iff i >= j
        const std::vector<size_t>& shell2bf() const {
          return shell2bf_;
        }
        /// Computes the map from shells to the corresponding atoms in \c atoms. If no atom matches the origin of a shell, it is mapped to -1.
        /// @note coordinates must match \em exactly , i.e. shell2atom[k] == l iff atoms[l].x == *this[k].O[0] && atoms[l].y == *this[k].O[1] &&  atoms[l].z == *this[k].O[2]
        /// @return the map from shell index to the atom in the list \c atoms that coincides with its origin;
        std::vector<long> shell2atom(const std::vector<Atom>& atoms) const {
          std::vector<long> result;
          result.reserve(size());
          for(const auto& s: *this) {
            auto a = std::find_if(atoms.begin(), atoms.end(), [&s](const Atom& a){ return s.O[0] == a.x && s.O[1] == a.y && s.O[2] == a.z; } );
            result.push_back( a != atoms.end() ? a - atoms.begin() : -1);
          }
          return result;
        }

      private:
        std::string name_;
        std::string customname_;
        long nbf_;
        size_t max_nprim_;
        int max_l_;
        std::vector<size_t> shell2bf_;
        // First int is the atom index (not label) it starts at 0
        // Second int is the number of basis functions associated with that atom
        std::map<int,int> nbf_per_atom_;

        // First int is the atom index (not label) it starts at 0
        // Second int is the group id 
        std::map<int,int> group_;
        // map of all the groups and the number of basis functions in each of them
        // first int is group ind
        // Second int is the number of basis functions
        std::map<int,long> groups_;

        void init() {
          nbf_ = nbf(*this);
          max_nprim_ = max_nprim(*this);
          max_l_ = max_l(*this);
          shell2bf_ = compute_shell2bf(*this);
          std::cerr << "calling init group" << std::endl;
          group_ = init_group();
          std::cerr << "calling nbf_" << std::endl;
          groups_[0]=nbf_;
          std::cerr << "Init Success" << std::endl;
        }

        struct canonicalizer {
            char operator()(char c) {
              char cc = ::tolower(c);
              switch (cc) {
                case '/': cc = 'I'; break;
              }
              return cc;
            }
        };

        static std::string canonicalize_name(const std::string& name) {
          auto result = name;
          std::transform(name.begin(), name.end(),
                         result.begin(), BasisSet::canonicalizer());
          return result;
        }

        // see http://www.gaussian.com/g_tech/g_ur/m_basis_sets.htm
        bool gaussian_cartesian_d_convention(const std::string& canonical_name) {
          // 3-21??g??, 4-31g??
          if (canonical_name.find("3-21")    == 0 ||
              canonical_name.find("4-31g")   == 0)
            return true;
          // 6-31??g?? but not 6-311 OR 6-31g()
          if (canonical_name.find("6-31") == 0 && canonical_name[4] != '1') {
            // to exclude 6-31??g() find the g, then check the next character
            auto g_pos = canonical_name.find('g');
            if (g_pos == std::string::npos) // wtf, I don't even know what this is, assume spherical d is OK
              return false;
            if (g_pos+1 == canonical_name.size()) // 6-31??g uses cartesian d
              return true;
            if (canonical_name[g_pos+1] == '*') // 6-31??g*? uses cartesian d
              return true;
          }
          return false;
        }
        
        /// decompose basis set name into components
        std::vector<std::string> decompose_name_into_components(std::string name) {
          std::vector<std::string> component_names;
          // aug-cc-pvxz* = cc-pvxz* + augmentation-... , except aug-cc-pvxz-cabs
          if ( (name.find("aug-cc-pv") == 0) && (name.find("cabs")==std::string::npos)  ) {
            std::string base_name = name.substr(4);
            component_names.push_back(base_name);
            component_names.push_back(std::string("augmentation-") + base_name);
          }
          else
            component_names.push_back(name);

          return component_names;
        }
        
        /** determines the path to the data directory, as follows:
         *       <ol>
         *         <li> specified by LIBINT_DATA_PATH environmental variable, if defined </li>
         *         <li> specified by DATADIR macro variable, if defined </li>
         *         <li> specified by SRCDATADIR macro variable, if defined </li>
         *         <li> hardwired to directory \c @DATADIR_ABSOLUTE@/basis </li>
         *       </ol>
         *  @throw std::runtime_error if the path is not valid, or cannot be determined
         *  @return valid path to the data directory
         */
        static std::string data_path() {
          std::string path;
          const char* data_path_env = getenv("LIBINT_DATA_PATH");
          if (data_path_env) {
            path = data_path_env;
          }
          else {
  #if defined(DATADIR)
            path = std::string{DATADIR};
  #elif defined(SRCDATADIR)
            path = std::string{SRCDATADIR};
  #else
            path = std::string("@DATADIR_ABSOLUTE@") + std::string("/basis");
  #endif
          }
          // validate path
          bool error = true;
          if (not path.empty()) {
            struct stat sb;
            error = (::stat(path.c_str(), &sb) == -1);
            error = error && not S_ISDIR(sb.st_mode);
          }
          if (error) {
            std::ostringstream oss; oss << "BasisSet::data_path(): path \"" << path << "\" is not valid";
            throw std::runtime_error(oss.str());
          }
          return path;
        }

      public:

      /**
       * \brief determines which atoms belong to which groups by reading a file
       *
       * The file has the .cst extension and contains the atom LABELS and the 
       * group ids (Group id 0 is the default) 
       * The groups are used during the scf calculation to enforce a probability
       * of 1 on the coefficients blonging to each group. The number of MO in which
       * the constraint is enforced depends on the number of basis functions that 
       * are in each group
       */
        void setConstraints(std::string cst_filename){
          if(not cst_filename.empty()){
            std::cout << "Will read constraint file " << cst_filename << std::endl;
            std::ifstream is(cst_filename);
            if(not is.good()){
              std::ostringstream oss;
              oss << "BasisSet::setConstraints(): file cannot be opened \"" << cst_filename << "\"" << std::endl;
              throw std::runtime_error(oss.str());
            }

            std::string line;
            std::getline(is,line); // Skip first line because it is a comment line
            
            while(std::getline(is,line)){
              std::istringstream iss(line);
              int atom_label;
              int group_id;
              iss >> atom_label;
              iss >> group_id;
              if(group_id<0){
                throw std::runtime_error("Group id must be a positive integer\n");
              }
              group_[(atom_label-1)] = group_id;
            }
          }

          // Determine how many basis functions are in each group
          groups_.clear();
          for( int atm_ind=0; atm_ind<group_.size();++atm_ind ){
            groups_[group_[atm_ind]] = groups_[group_[atm_ind]] + boost::lexical_cast<long>(nbf_per_atom_[atm_ind]); 
          }

        }

      /** 
       * \brief Read in the atom labels the basis sets that are to be associated with them 
       * 
       * Also the coefficients to be used by choosing from an exsisting element
       * @return map of atom labels with map of element and key of basis set string
       *
       * E.g. if in my geometry file atom 5 is a Oxygen and I want to use the basis set 
       * of 6-311 with the coefficients of a carbon 
       *
       * basis_cust[5]["C"] = "6-311";
       *
       * The Z value is not changed here only the coefficients that are used
       */
        std::map<int, std::map<std::string,std::string > > read_custom(std::string customfile){

          std::map<int,std::map<std::string,std::string>> cust_basis;
          if(customname_.compare("")!=0){

            std::cout << "Will read custom file " << customfile << std::endl;
            std::ifstream is(customfile);
            if(not is.good()) {
              std::ostringstream oss;
              oss << "BasisSet::read_custom(): file cannot be opened \"" << customfile << "\"" << std::endl;
              throw std::runtime_error(oss.str());
            }

            std::string line;
            std::getline(is,line); // Skip first line because it is a comment line

            while(std::getline(is,line)){
              std::istringstream iss(line);
              int atom_label;
              std::string atom_basis;
              std::string atom_coef_type;
              iss >> atom_label;
              iss >> atom_basis;
              iss >> atom_coef_type;
              cust_basis[atom_label][atom_coef_type]=atom_basis; 
            }
          } 

          return cust_basis;
        }

      /** reads in all basis sets from a Gaussian94-formatted basis set file (see https://bse.pnl.gov/bse/portal)
       *  @param[in] file_dot_g94 file name
       *  @throw std::runtime_error if the path is not valid, or cannot be determined
       *  @return vector of basis sets for each element
       */
      static std::vector<std::vector<libint2::Shell>> read_g94_basis_library(std::string file_dot_g94,
                                                                             bool force_cartesian_d = false) {

        std::cout << "Will read basis set from " << file_dot_g94 << std::endl;
        std::ifstream is(file_dot_g94);
        if (not is.good()) {
          std::ostringstream oss;
          oss << "BasisSet::read_g94_basis_library(): could not open \"" << file_dot_g94 << "\"" << std::endl;
          throw std::runtime_error(oss.str());
        }
        std::vector<std::vector<libint2::Shell>> ref_shells(118); // 118 = number of chemical elements

        std::string comment, rest;

        // skip till first basis
        while(std::getline(is, comment) && comment != "****") {
        }

        size_t Z;
        auto nextbasis = true, nextshell = false;
        // read lines till end
        while(std::getline(is, comment)) {
          // skipping empties and starting with '!' (the comment delimiter)
          if (comment.empty() || comment[0] == '!') continue;
          if (comment == "****") {
            nextbasis = true;
            nextshell = false;
            continue;
          }
          if (nextbasis) {
            nextbasis = false;
            std::istringstream iss(comment);
            std::string elemsymbol;
            iss >> elemsymbol >> rest;

            bool found = false;
            using libint2::chemistry::element_info;
            for(const auto& e: element_info) {
              if (strcaseequal(e.symbol, elemsymbol)) {
                Z = e.Z;
                found = true;
                break;
              }
            }
            if (not found) {
              std::ostringstream oss;
              oss << "in file " << file_dot_g94
                  << " found G94 basis set for element symbol \""
                  << elemsymbol << "\", not found in Periodic Table.";
              throw std::runtime_error(oss.str());
            }

            nextshell = true;
            continue;
          }
          if (nextshell) {
            std::istringstream iss(comment);
            std::string amlabel;
            unsigned nprim;
            iss >> amlabel >> nprim >> rest;
            if (amlabel != "SP" && amlabel != "sp") {
              assert(amlabel.size() == 1);
              auto l = Shell::am_symbol_to_l(amlabel[0]);
              std::vector<double> exps;
              std::vector<double> coeffs;
              for(auto p = 0; p!=nprim; ++p) {
                while(std::getline(is, comment) && (comment.empty() || comment[0] == '!')) {}
                std::istringstream iss(comment);
                double e, c;
                iss >> e >> c;
                exps.emplace_back(e);
                coeffs.emplace_back(c);
              }
              auto pure = force_cartesian_d ? (l>2) : (l>1);
              ref_shells[Z].push_back(
                  libint2::Shell{
                    exps,
                    {
                      {l, pure, coeffs}
                    },
                    {{0.0, 0.0, 0.0}}
                  }
              );
            }
            else { // split the SP shells
              std::vector<double> exps;
              std::vector<double> coeffs_s, coeffs_p;
              for(auto p = 0; p!=nprim; ++p) {
                while(std::getline(is, comment) && (comment.empty() || comment[0] == '!')) {}
                std::istringstream iss(comment);
                double e, c1, c2;
                iss >> e >> c1 >> c2;
                exps.emplace_back(e);
                coeffs_s.emplace_back(c1);
                coeffs_p.emplace_back(c2);
              }
              ref_shells[Z].push_back(
                  libint2::Shell{exps,
                {
                 {0, false, coeffs_s}
                },
                {{0.0, 0.0, 0.0}}
              }
              );
              ref_shells[Z].push_back(
                  libint2::Shell{ exps,
                {
                 {1, false, coeffs_p}
                },
                {{0.0, 0.0, 0.0}}
              }
              );
            }
          }
        }


        std::cout << " Ref shell for H size " << ref_shells.at(1).size() << std::endl;
        std::cout << " Ref shell for O size " << ref_shells.at(8).size() << std::endl;
        return ref_shells;
      }

      static size_t nbf(const std::vector<libint2::Shell>& shells) {
        size_t n = 0;
        // Shells appear in the same order as the atoms
        for (const auto& shell: shells){
          n += shell.size();
        }
        return n;
      }

      static size_t max_nprim(const std::vector<libint2::Shell>& shells) {
        size_t n = 0;
        for (auto shell: shells)
          n = std::max(shell.nprim(), n);
        return n;
      }

      static int max_l(const std::vector<libint2::Shell>& shells) {
        int l = 0;
        for (auto shell: shells)
          for (auto c: shell.contr)
            l = std::max(c.l, l);
        return l;
      }

      static std::vector<size_t> compute_shell2bf(const std::vector<libint2::Shell>& shells) {
        std::vector<size_t> result;
        result.reserve(shells.size());

        size_t n = 0;
        for (auto shell: shells) {
          result.push_back(n);
          n += shell.size();
        }

        return result;
      }

  }; // BasisSet

} // namespace libint2

#endif /* _libint2_src_lib_libint_basis_h_ */
